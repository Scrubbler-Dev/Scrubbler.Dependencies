name: Bump consumers to Scrubbler.Dependencies tag

on:
  push:
    tags:
      - "v*"
      - "deps-*"

permissions:
  contents: read

jobs:
  bump:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Scrubbler.Dependencies
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute tag + deps commit
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF_NAME}"
          COMMIT="$(git rev-list -n 1 "$TAG")"
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "commit=$COMMIT" >> "$GITHUB_OUTPUT"

      - name: Bump submodule in consumer repos and open PRs
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.SCRUBBLER_PLUGINS_PAT }}
          OWNER: Scrubbler-Dev
          # space-separated list of possible submodule paths
          SUBMODULE_PATHS: "deps Scrubbler/deps"
          COPY_GLOBAL_JSON: "true"
          TAG: ${{ steps.meta.outputs.tag }}
          DEPS_COMMIT: ${{ steps.meta.outputs.commit }}
        run: |
          set -euo pipefail

          git config --global user.email "actions@github.com"
          git config --global user.name "github-actions"

          BRANCH="chore/bump-deps-${TAG}"
          TITLE="chore: bump Scrubbler.Dependencies to ${TAG}"
          BODY="This PR bumps the Scrubbler.Dependencies submodule to tag ${TAG} (${DEPS_COMMIT})."

          echo "Discovering repositories..."

          gh repo list "$OWNER" --limit 500 \
            --json name,isArchived,isFork,defaultBranchRef \
            -q '.[] | select(.isArchived==false and .isFork==false) | [.name, .defaultBranchRef.name] | @tsv' \
            > repos.txt

          processed=0
          updated=0
          skipped=0
          failed=0

          while IFS=$'\t' read -r REPO DEFAULT_BRANCH
          do
            [ -n "$REPO" ] || continue
            DEFAULT_BRANCH="${DEFAULT_BRANCH:-main}"

            echo "======================================"
            echo "Processing: $OWNER/$REPO"
            echo "Default branch: $DEFAULT_BRANCH"
            echo "======================================"

            # Check for .gitmodules
            if ! gh api "repos/$OWNER/$REPO/contents/.gitmodules" >/dev/null 2>&1; then
              echo "No .gitmodules → skipping"
              skipped=$((skipped+1))
              continue
            fi

            # Fetch and decode .gitmodules content
            gitmodules_content="$(gh api "repos/$OWNER/$REPO/contents/.gitmodules" -q '.content' | base64 -d || true)"

            # Find the first matching submodule path
            FOUND_SUBMODULE_PATH=""
            for p in $SUBMODULE_PATHS; do
              if echo "$gitmodules_content" | grep -qE "^[[:space:]]*path[[:space:]]*=[[:space:]]*$p[[:space:]]*$"; then
                FOUND_SUBMODULE_PATH="$p"
                break
              fi
            done

            if [ -z "$FOUND_SUBMODULE_PATH" ]; then
              echo "No matching deps submodule path found (expected one of: $SUBMODULE_PATHS) → skipping"
              skipped=$((skipped+1))
              continue
            fi

            echo "Using submodule path: $FOUND_SUBMODULE_PATH"

            processed=$((processed+1))

            WORKDIR=$(mktemp -d)
            if ! git clone "https://x-access-token:$GH_TOKEN@github.com/$OWNER/$REPO.git" "$WORKDIR"; then
              echo "Clone failed → skipping"
              failed=$((failed+1))
              rm -rf "$WORKDIR"
              continue
            fi

            cd "$WORKDIR"

            if ! git checkout "$DEFAULT_BRANCH"; then
              echo "Failed to checkout $DEFAULT_BRANCH → skipping"
              failed=$((failed+1))
              cd /
              rm -rf "$WORKDIR"
              continue
            fi

            git pull

            git submodule update --init --recursive

            if [ ! -d "$FOUND_SUBMODULE_PATH" ]; then
              echo "Expected submodule directory '$FOUND_SUBMODULE_PATH' not present after init → skipping"
              failed=$((failed+1))
              cd /
              rm -rf "$WORKDIR"
              continue
            fi

            # Update submodule to deps commit
            cd "$FOUND_SUBMODULE_PATH"
            git fetch --all --tags
            git checkout "$DEPS_COMMIT"
            cd ..

            # Optional: copy deps/global.json to repo root
            if [ "$COPY_GLOBAL_JSON" = "true" ] && [ -f "$FOUND_SUBMODULE_PATH/global.json" ]; then
              cp -f "$FOUND_SUBMODULE_PATH/global.json" "./global.json"
              git add "./global.json"
            fi

            git add "$FOUND_SUBMODULE_PATH"

            if git diff --cached --quiet; then
              echo "Already up to date."
              cd /
              rm -rf "$WORKDIR"
              continue
            fi

            git checkout -B "$BRANCH"
            git commit -m "$TITLE"
            git push -u origin "$BRANCH" --force-with-lease

            set +e
            gh pr create \
              --repo "$OWNER/$REPO" \
              --head "$BRANCH" \
              --base "$DEFAULT_BRANCH" \
              --title "$TITLE" \
              --body "$BODY"
            pr_status=$?
            set -e

            if [ $pr_status -ne 0 ]; then
              echo "PR create failed (likely already exists). Listing matching PRs:"
              gh pr list --repo "$OWNER/$REPO" --head "$BRANCH" --json number,title,url -q '.[] | "\(.number) \(.title) \(.url)"'
            fi

            updated=$((updated+1))

            cd /
            rm -rf "$WORKDIR"

          done < repos.txt

          echo "======================================"
          echo "Processed: $processed"
          echo "Updated:   $updated"
          echo "Skipped:   $skipped"
          echo "Failed:    $failed"
          echo "======================================"

          if [ "$failed" -ne 0 ]; then
            exit 1
          fi